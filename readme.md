## Описание проекта (смысл, цель, результат)

Я разработал fullstack CRUD-приложение для управления контактами: **React-клиент** (UI/UX, формы, таблица) + **ASP.NET Core Web API** (эндпоинты, модели, DI) + **SQLite** (хранение данных).
Цель проекта — показать полный цикл разработки небольшого продукта: от прототипа интерфейса до подключения API и базы данных, с постепенным улучшением архитектуры и пользовательского опыта.

**Результат:** приложение позволяет просматривать список контактов, добавлять новые записи с валидацией, удалять контакты, а на серверной части реализованы CRUD-операции и переход от in-memory хранения к SQLite. Конфигурация подключения к БД вынесена в `appsettings`, что позволяет менять базу без правок кода.

---

## Структура репозитория и ветки

* **main** — рабочая ветка, где лежат:

  * `client` — React-приложение (компоненты, форма, таблица, axios-запросы)
  * `api` — ASP.NET Core Web API (контроллеры, модели, DI, конфиги)

* **sql-migration** — ветка, подготовленная для слияния с `main`, где:

  * добавлена SQLite-БД
  * реализован класс SQL storage, который реализует интерфейс хранения
  * проект ушёл от прототипа “данные в памяти” к реальной базе

---

## Как развивался проект по этапам (по твоим коммитам)

### 1) Старт и базовая структура UI (Nov 24–29, 2025)

Сначала я поднял каркас проекта и собрал структуру React-приложения:

* задал базовую структуру и разметку приложения (`feach(App.js): структура веб-приложения`)
* подключил Bootstrap и привёл UI к читаемому виду (`feach(Bootstrap)`)
* вынес таблицу в отдельный компонент и разнёс логику по файлам (`refactoring(TableContact)`, `refactoring(contact)`)
* почистил лишнее после генерации проекта (`DELETE(react api)`)

**Итог этапа:** появился минимальный UI-каркас и таблица контактов как отдельный компонент.

---

### 2) Приведение модели под ТЗ и улучшение отображения (Jan 5–16, 2026)

Потом я привёл сущность контакта к требованиям и начал наводить порядок в логике формы:

* изменил сущность `Contact` под поля ТЗ: `Name`, `MobilePhone`, `JobTitle`, `BirthDate` (`refactor(Contact)`)
* синхронизировал изменения на сервере и в логике обновления (`refactor(API)`)
* сделал таблицу контактов и добавил форматирование даты, чтобы корректно отображать разные форматы (`feach(Table): форматирование даты`)
* добавил форму создания контакта и постепенно прокачал её через хуки + валидацию + очистку после успешного добавления
  (`feach(FormContact): сделали хуки`, `сделал валидацию`, `запускаем валидацию и очищаем форму`, `fix(FormContact)`)

**Итог этапа:** форма стала “защищённой” от мусорных данных, UX стал адекватным (ошибки, очистка формы), данные соответствуют ТЗ.

---

### 3) UX-решение: удаление “без сломанной таблицы” (Jan 18, 2026)

Когда дошёл до удаления, возникла типичная проблема таблиц: колонка “Действия” ломает внешний вид, даже если кнопку скрывать.
Я сделал удаление через **hover overlay**, чтобы таблица не резервировала место под колонку:

* добавил состояние `hoveredId`
* отслеживал hover по строке
* кнопку рендерил как overlay-элемент, не влияющий на табличную сетку
  (`feach(Form,Table,JSX): реализовано удаление контакта при наведении`)

**Итог этапа:** удаление работает и выглядит аккуратно, без “пустых колонок” и визуального мусора.

---

### 4) Подключение API: Axios, CORS, env (Jan 18–20, 2026)

Дальше проект перешёл от локального состояния к реальному backend-взаимодействию:

* подключил Axios и настроил CORS на сервере, проверил получение данных (на раннем этапе логировал в консоль)
  (`feach(Axios и CORS)`)
* вынес адрес API в окружение (`feach(API): сделал env сервер отдельно`)
* настроил загрузку данных через `axios.get` и `useEffect`
  (`feach(App): настройка Get-запроса`)
* добавил POST-запрос на создание контакта и DELETE-запрос на удаление
  (`Feach(JSX): сделал Post`, `feach(JSX): сделал DELETE`)

**Итог этапа:** фронт стал реально работать с сервером по HTTP, CRUD начал превращаться в “настоящее приложение”.

---

### 5) Переход на SQLite и нормальная архитектура хранения (Jan 22, 2026)

Следующий шаг — убрать in-memory и подключить SQLite:

* создал класс SQL storage и реализовал интерфейс хранения, чтобы контроллеры не зависели от конкретной БД
  (`feach(SQL): создали класс SQL storage и реализовали интерфейс`)
* фактически реализовал переход “память → SQLite” без переписывания логики контроллеров (через контракт хранения)

**Итог этапа:** данные стали храниться в БД, проект стал ближе к production-подходу.

